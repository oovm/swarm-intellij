{
    parserClass = "swarm.intellij.language.parser.SwarmParser"
    parserUtilClass = "com.intellij.lang.parser.GeneratedParserUtilBase"

    psiClassPrefix = "Swarm"
    psiImplClassSuffix = "Node"
    psiPackage = "swarm.intellij.language.psi"
    psiImplPackage = "swarm.intellij.language.psi_node"

    elementTypeHolderClass = "swarm.intellij.language.psi.SwarmTypes"
    elementTypeClass = "swarm.intellij.language.psi.SwarmElementType"
    tokenTypeClass = "swarm.intellij.language.psi.SwarmElementType"

    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiImplUtilClass = "swarm.intellij.language.psi_node.SwarmPsiExtension"

    tokens = [
        AS = "as"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ACCENT = '^'
        ANGLE_L = '<'
        ANGLE_R = '>'
        QUOTATION = '"'
        ESCAPE = '\'
        TAGGED = '<-'
        TO = '->'

        SOFT_CONNECT = '~'
        CHOOSE='|'

        EQ = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        AT = '@'
        HYPHEN = '-'
        NOT='!'
        OPTIONAL='?'
        MANY1 = '+'
        MANY = '*'
    ]
}

Swarm ::= statements*;
// fake used for mixin
// pri used for syntax highlight
fake comment_doc ::= COMMENT_DOC;
private comment ::= COMMENT_LINE | COMMENT_BLOCK | COMMENT_DOC;

private statements ::=
      namespace_statement
    | import_statement
    | task_statement
    | macro_call
    | SEMICOLON;
// ---------------------------------------------------------------------------------------------------------------------
// @grammar swarm {"*.yg","*.swarm", "*.grammar"}
// @grammar swarm;
namespace_statement ::= KW_NAMESPACE namespace {
    pin = namespace
};
// ---------------------------------------------------------------------------------------------------------------------
import_statement ::= KW_IMPORT string_literal [import_body] {
    pin = string_literal
}
import_body      ::= BRACE_L [identifier (COMMA identifier)* [COMMA]] BRACE_R;
// ---------------------------------------------------------------------------------------------------------------------



macro_arg ::= value;
// =====================================================================================================================
// def modifiers rule
task_statement ::= KW_TASK modifiers namespace cmd_block {
    pin = namespace
    mixin = "swarm.intellij.language.mixin.MixinTaskStatement"
};
// ---------------------------------------------------------------------------------------------------------------------
input_statement ::= KW_INPUT BRACE_L [define_pair (COMMA define_pair)* COMMA?] BRACE_R {
//    mixin = "swarm.intellij.language.mixin.MixinInputStatement"
};
define_pair      ::= identifier [COLON define_type] [EQ expr] {
    mixin = "swarm.intellij.language.mixin.MixinDefineParameter"
}
define_type      ::= identifier;
// =====================================================================================================================
cmd_block       ::= BRACE_L cmd_statement* BRACE_R {
    mixin = "swarm.intellij.language.mixin.MixinRuleBody"
}
cmd_statement ::=
      input_statement
    | cmd_pair
    | function_call
    | SEMICOLON
    | COMMA
    ;
cmd_pair   ::= namespace [COLON] cmd_value;
cmd_value  ::= BOOLEAN | num | string_literal | cmd_block | function_call;
// ---------------------------------------------------------------------------------------------------------------------
// @function("path")
function_call ::= namespace function_args [cmd_block];
function_args ::= PARENTHESIS_L fn_statement* PARENTHESIS_R;
fn_statement  ::= fn_pair|COMMA;
fn_pair   ::= [key (EQ|COLON)] cmd_value;


expr ::= term (infix term | term)*;
term ::= (prefix)* atom (suffix)*
atom ::= PARENTHESIS_L expr PARENTHESIS_R | field_mark | function_call | value;
// =====================================================================================================================
macro_call  ::= HASH identifier;
// =====================================================================================================================
rule_expr ::= rule_term (infix rule_term | rule_term)*;
rule_term ::= (prefix)* rule_atom (suffix| range)*
rule_atom ::=
    PARENTHESIS_L [CHOOSE] rule_expr PARENTHESIS_R | field_mark | branch_mark | function_call |
    num | string_literal | namespace | charset;
infix ::= CHOOSE | SOFT_CONNECT;
prefix ::= ACCENT;
suffix ::= OPTIONAL | MANY | MANY1;
// ---------------------------------------------------------------------------------------------------------------------
field_mark ::= identifier COLON field_rhs;
field_rhs  ::= identifier | charset | string_literal;
// ---------------------------------------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------------------------------------
value ::= BOOLEAN | num | string_literal | table | namespace | charset;
type_hint ::= identifier;
charset ::= REGEX_RANGE;
// ---------------------------------------------------------------------------------------------------------------------
pair ::= symbol_path eq value;
symbol_path ::= key (DOT key)*
key ::= string_literal | key_symbol | INTEGER;
private eq ::= EQ | COLON;
key_symbol ::= SYMBOL;
// ---------------------------------------------------------------------------------------------------------------------
private num ::= [SIGN] (INTEGER | NUMBER | BYTE);
// ---------------------------------------------------------------------------------------------------------------------
string_literal ::= esc | STRING_SQ char* STRING_SQ | STRING_DQ char* STRING_DQ | char+;
private char ::= CHARACTER | esc;
private esc ::= ESCAPE_UNICODE | ESCAPE_SPECIAL;
// ---------------------------------------------------------------------------------------------------------------------
table ::= [type_hint] <<paired table_inner>>;
private table_inner ::= [table_item (COMMA table_item)* [COMMA]];
private table_item ::= pair | value;
// ---------------------------------------------------------------------------------------------------------------------
object ::= BRACE_L (object_item [COMMA|SEMICOLON])* BRACE_R
object_item ::= object_key COLON value;
object_key ::= identifier | string_literal;
// ---------------------------------------------------------------------------------------------------------------------
modifiers ::= (identifier !('('|'{'|ARROW|DOT|HYPHEN|COLON))*;
namespace ::= identifier ((DOT|DOUBLE_COLON) identifier)*
identifier ::= SYMBOL {
    mixin = "swarm.intellij.language.mixin.MixinIdentifier"
}
// ---------------------------------------------------------------------------------------------------------------------
meta parenthesis ::= PARENTHESIS_L [<<item>> (<<delimiter>> <<item>>)* <<delimiter>>?] PARENTHESIS_R;

private meta paired ::=
    PARENTHESIS_L <<param>> PARENTHESIS_R
  | BRACKET_L <<param>> BRACKET_R
  | BRACE_L <<param>> BRACE_R
